package quickgraph

import (
	"context"
	"strings"
	"testing"
)

// Security vulnerability tests for nested alias counting and complex fragment depth
// These tests verify that the GraphQL library properly handles potential security vulnerabilities

// Test nested alias counting vulnerabilities - SECURITY VULNERABILITY TESTS
func TestNestedAliasCountingVulnerability(t *testing.T) {
	// Test type with multiple fields for nested aliasing
	type VulnTestNode struct {
		ID       string          `json:"id"`
		Name     string          `json:"name"`
		Email    string          `json:"email"`
		Status   string          `json:"status"`
		Children []*VulnTestNode `json:"children"`
	}

	g := &Graphy{
		QueryLimits: &QueryLimits{
			MaxAliases: 2, // Very restrictive alias limit
		},
	}

	g.RegisterQuery(context.Background(), "user", func(ctx context.Context) *VulnTestNode {
		return &VulnTestNode{
			ID:     "1",
			Name:   "Test",
			Email:  "test@example.com",
			Status: "active",
			Children: []*VulnTestNode{
				{ID: "2", Name: "Child1", Email: "child1@example.com", Status: "pending"},
				{ID: "3", Name: "Child2", Email: "child2@example.com", Status: "active"},
			},
		}
	})

	t.Run("Current Implementation - Top Level Aliases Only", func(t *testing.T) {
		// This query should fail due to 3 top-level aliases (limit is 2)
		query := `{
			u1: user { id }
			u2: user { id } 
			u3: user { id }
		}`

		_, err := g.ProcessRequest(context.Background(), query, "")
		if err == nil {
			t.Errorf("Expected query to be rejected due to too many top-level aliases")
		} else if !strings.Contains(err.Error(), "exceeds maximum allowed aliases") {
			t.Errorf("Expected alias limit error, got: %v", err)
		}
	})

	t.Run("SECURE - Field-Level Aliases Not Supported", func(t *testing.T) {
		// This GraphQL implementation doesn't support field-level aliases
		// which is actually a security feature preventing alias explosion attacks
		query := `{
			user {
				userId: id
				userName: name
			}
		}`

		// This query should be rejected due to syntax error (field aliases not supported)
		_, err := g.ProcessRequest(context.Background(), query, "")
		if err != nil {
			t.Logf("Query correctly rejected - field aliases not supported (secure): %v", err)
			if !strings.Contains(err.Error(), "error parsing request") {
				t.Errorf("Expected parsing error, got: %v", err)
			}
		} else {
			t.Errorf("Expected query to be rejected due to field alias syntax not being supported")
		}
	})

	t.Run("VULNERABILITY - Nested Command Alias Bypass via Multiple Operations", func(t *testing.T) {
		// Test bypassing alias limits by using multiple operations with few aliases each
		query := `
		query Op1 {
			first: user { id }
			second: user { name }  
		}
		query Op2 {
			third: user { email }
			fourth: user { status }
		}`

		result, err := g.ProcessRequest(context.Background(), query, "")
		if err != nil {
			t.Logf("Query correctly rejected: %v", err)
		} else {
			t.Logf("Query accepted - checking if multiple operations bypass alias limits")
			aliasCount := strings.Count(result, "first") + strings.Count(result, "second") +
				strings.Count(result, "third") + strings.Count(result, "fourth")

			if aliasCount > 2 {
				t.Errorf("POTENTIAL VULNERABILITY: %d command aliases across multiple operations (limit=2)", aliasCount)
			}
		}
	})
}

// Test complex fragment depth vulnerabilities - SECURITY VULNERABILITY TESTS
func TestComplexFragmentDepthVulnerability(t *testing.T) {
	type VulnFragment struct {
		ID       string          `json:"id"`
		Name     string          `json:"name"`
		Children []*VulnFragment `json:"children"`
		Parent   *VulnFragment   `json:"parent"`
	}

	g := &Graphy{
		QueryLimits: &QueryLimits{
			MaxDepth: 3, // Restrictive depth limit
		},
	}

	g.RegisterQuery(context.Background(), "node", func(ctx context.Context) *VulnFragment {
		// Create a structure deep enough to test limits
		level4 := &VulnFragment{ID: "level4", Name: "Level4"}
		level3 := &VulnFragment{ID: "level3", Name: "Level3", Children: []*VulnFragment{level4}}
		level2 := &VulnFragment{ID: "level2", Name: "Level2", Children: []*VulnFragment{level3}}
		level1 := &VulnFragment{ID: "level1", Name: "Level1", Children: []*VulnFragment{level2}}
		root := &VulnFragment{ID: "root", Name: "Root", Children: []*VulnFragment{level1}}

		return root
	})

	t.Run("Standard Fragment Depth - Should Fail", func(t *testing.T) {
		// Standard deep query that should fail (depth = 5, limit = 3)
		query := `{
			node {
				id
				children {
					id
					children {
						id
						children {
							id
							children {
								id
							}
						}
					}
				}
			}
		}`

		result, err := g.ProcessRequest(context.Background(), query, "")
		if err == nil {
			t.Errorf("Expected query to be rejected due to depth limit")
			t.Logf("Unexpected success result: %s", result)
		} else if !strings.Contains(err.Error(), "exceeds maximum allowed depth") {
			t.Errorf("Expected depth limit error, got: %v", err)
		}
	})

	t.Run("VULNERABILITY - Inline Fragment Depth Bypass", func(t *testing.T) {
		// Complex inline fragments might confuse depth calculation
		query := `{
			node {
				id
				... on VulnFragment {
					name
					children {
						id
						... on VulnFragment {
							name
							children {
								id
								... on VulnFragment {
									name
									children {
										id
										... on VulnFragment {
											name
											children {
												id
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}`

		result, err := g.ProcessRequest(context.Background(), query, "")
		if err != nil {
			t.Logf("Query correctly rejected: %v", err)
		} else {
			t.Logf("POTENTIAL VULNERABILITY: Complex inline fragments may bypass depth limits")
			depthCheck := strings.Count(result, "children")
			if depthCheck > 3 {
				t.Errorf("VULNERABILITY: Query depth appears to exceed limit (found %d levels)", depthCheck)
			}
		}
	})

	t.Run("VULNERABILITY - Mixed Fragment Types", func(t *testing.T) {
		// Mix of named and inline fragments
		query := `{
			node {
				...nodeInfo
				children {
					...deepNodeInfo
				}
			}
		}
		
		fragment nodeInfo on VulnFragment {
			id
			name
			... on VulnFragment {
				children {
					id
					children {
						id
					}
				}
			}
		}
		
		fragment deepNodeInfo on VulnFragment {
			id
			name
			children {
				id
				name
				children {
					id
					name
				}
			}
		}`

		result, err := g.ProcessRequest(context.Background(), query, "")
		if err != nil {
			t.Logf("Query correctly rejected: %v", err)
		} else {
			t.Logf("POTENTIAL VULNERABILITY: Mixed fragment types may confuse depth calculation")
			// Check if we got deeper than expected
			if strings.Contains(result, "children") {
				childrenCount := strings.Count(result, "\"children\":")
				if childrenCount > 2 {
					t.Errorf("VULNERABILITY: Mixed fragments may have bypassed depth limits")
				}
			}
		}
	})
}

// Test fragment and alias interaction vulnerabilities
func TestFragmentAliasInteraction(t *testing.T) {
	type InteractionNode struct {
		ID    string `json:"id"`
		Name  string `json:"name"`
		Value int    `json:"value"`
	}

	g := &Graphy{
		QueryLimits: &QueryLimits{
			MaxAliases: 2,
			MaxDepth:   3,
		},
	}

	g.RegisterQuery(context.Background(), "data", func(ctx context.Context) *InteractionNode {
		return &InteractionNode{ID: "1", Name: "Test", Value: 42}
	})

	t.Run("SECURE - Fragment Command Aliases Are Properly Counted", func(t *testing.T) {
		// Test that command aliases (not field aliases) are properly counted with fragments
		query := `{
			first: data {
				...simpleFields
			}
			second: data {
				...simpleFields  
			}
			third: data {
				...simpleFields
			}
		}
		
		fragment simpleFields on InteractionNode {
			id
			name
			value
		}`

		_, err := g.ProcessRequest(context.Background(), query, "")
		if err != nil {
			t.Logf("Query correctly rejected due to too many command aliases: %v", err)
			if !strings.Contains(err.Error(), "exceeds maximum allowed aliases") {
				t.Errorf("Expected alias limit error, got: %v", err)
			}
		} else {
			t.Errorf("Expected query to be rejected due to 3 command aliases exceeding limit of 2")
		}
	})
}

// Test DoS scenarios combining multiple vulnerabilities
func TestDenialOfServiceScenarios(t *testing.T) {
	type DoSNode struct {
		ID       string     `json:"id"`
		Children []*DoSNode `json:"children"`
	}

	g := &Graphy{
		QueryLimits: &QueryLimits{
			MaxAliases: 5,
			MaxDepth:   3,
		},
	}

	g.RegisterQuery(context.Background(), "root", func(ctx context.Context) *DoSNode {
		// Create a tree structure for testing
		return &DoSNode{
			ID: "root",
			Children: []*DoSNode{
				{ID: "child1", Children: []*DoSNode{{ID: "grandchild1"}}},
				{ID: "child2", Children: []*DoSNode{{ID: "grandchild2"}}},
			},
		}
	})

	t.Run("SECURE - Many Command Aliases Are Properly Limited", func(t *testing.T) {
		// Generate many command aliases to test if they're limited
		query := `{
			a1: root { id }
			a2: root { id }
			a3: root { id }
			a4: root { id }
			a5: root { id }
			a6: root { id }
		}`

		_, err := g.ProcessRequest(context.Background(), query, "")
		if err != nil {
			t.Logf("Query correctly rejected due to too many command aliases: %v", err)
			if !strings.Contains(err.Error(), "exceeds maximum allowed aliases") {
				t.Errorf("Expected alias limit error, got: %v", err)
			}
		} else {
			t.Errorf("Expected query to be rejected due to 6 command aliases exceeding limit of 5")
		}
	})

	t.Run("VULNERABILITY - Fragment Depth Bypass Attempt", func(t *testing.T) {
		// Try to bypass depth limits using fragments
		query := `{
			root {
				...deepFragment
			}
		}
		
		fragment deepFragment on DoSNode {
			id
			children {
				id
				children {
					id
					children {
						id
						children {
							id
						}
					}
				}
			}
		}`

		_, err := g.ProcessRequest(context.Background(), query, "")
		if err != nil {
			t.Logf("Query correctly rejected due to depth limit: %v", err)
			if !strings.Contains(err.Error(), "exceeds maximum allowed depth") {
				t.Errorf("Expected depth limit error, got: %v", err)
			}
		} else {
			t.Errorf("Expected query to be rejected due to depth exceeding limit of 3")
		}
	})
}
